<!-- 단순한 책 내용만 정리하는 스터디에서 벗어나 자신의 생각을 정리하고, 그걸 바탕으로 실무에 적용할 수 있는 내용을 찾는 스터디가 되었으면 좋겠습니다. -->
<!-- 참고한 글 - https://tech.kakaopay.com/post/frontend-study-journey/ -->

> [!Note]
> 정리한 챕터나 페이지 등을 자유롭게 기록

## Summary

<!-- 한 줄 요약을 통해 발표자는 본인이 주제를 정확하게 이해했는지 점검하고, 스터디원들은 한 눈에 주제를 파악할 수 있습니다. -->

- 레거시 코드에서 테스트코드를 도입하는 경우에, 적절한 접근 방법에 대해 알아본다.

## Concept

<!-- 책을 바탕으로 발표 주제의 이론적 개념 및 필요한 배경 지식을 설명합니다. -->

> 레거시 코드로 인하여 TDD 를 적용하기 힘든 경우
>
> - 기존 코드를 대상으로 테스트를 작성하는 것에 어려움이 있음.
> - 기존 코드를 리팩토링하는 것이 거의 불가능하거나 시간적 여유가 없음.
> - 본인이 설계한 코드를 바꾸려고 하지 않음.
> - TDD 를 활용할 수 있는 도구가 부족하거나 도구 자체가 TDD 진행에 방해가 된다.
> - 어디에서부터 시작해야 할지 판단하기 어려움.

기존 프로젝트에 테스트를 추가가 힘들 때, 보통은 기존 컴포넌트를 확장하거나 대체할 수 있는 적절한 지점(**심**)없이 작성된 경우가 많음.

그렇다면, 어떻게 접근을 해야할까? 아래 2가지에 초점을 맞춰서 접근을 하자.

1. 테스트를 어디에서부터 시작하고 어느 부분에 집중해야 할 지
2. 테스트가 없는 상태에서 기존 기능을 망가뜨리지 않은 채 어떻게 안전하게 코드를 리팩터링 할 지

### 어디에서부터 테스트를 시작할까?

먼저 아래와 같이 항목에 따라 우선순위를 정해야 한다.

1. 논리적 복잡도: 컴포넌트 내에 존재하는 논리 구조의 복잡성
   - if문, switch문 재귀 호출 등이 해당
   - 순환 복잡도라고도 하며 다양한 도구를 활용해 측정 가능
2. 의존성 수준: 의존하는 외부 요소의 개수
   - 외부에 있는 이메일 서비스, 데이터베이스 시스템에 연동되거나
   - 정적 로그 메서드를 호출하는 경우
3. 우선 순위: 프로젝트 내에서 차지하는 중요도

#### 테스트 가능성 표 예시

| 컴포넌트      | 논리적 복잡도 | 의존성 수준 | 우선순위 | 비고                                                                                                                                                                                |
| ------------- | ------------- | ----------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Utils         | 6             | 1           | 5        | 의존성은 적지만 많은 로직을 포함하고 있음. 테스트하기 쉬우며 테스트를 작성할 때 얻을 수 있는 이점이 많다.                                                                           |
| Person        | 2             | 1           | 1        | 로직이 거의 없고 의존성도 없는 단순 데이터 저장용 클래스. 테스트할 가치는 거의 없다.                                                                                                |
| TextParser    | 8             | 4           | 6        | 이 클래스는 로직과 의존성이 모두 많다. 또 프로젝트에서 우선순위가 높은 작업에 속해 있다. 테스트 가치는 높아 큰 효과를 기대할 수 있지만, 난도가 높고 시간이 많이 걸릴 것으로 보인다. |
| ConfigManager | 1             | 6           | 1        | 이 클래스는 설정 관련 데이터를 관리하고 디스크에서 파일을 읽는다. 로직은 적지만 의존성이 많다. 테스트 가치도 적고 난도도 높아 시간이 많이 소요될 것으로 보인다.                     |

==> 특정 임계 값(2~3) 이하인 항목들은 무시해도 되므로, Person 과 ConfigManager 는 테스트에서 제외한다.

로직 중심의 항목은 비교적 테스트하기가 쉽고, 의존성 중심의 항목은 복잡하고 테스트에 어려움을 가지고있다.

### 무엇을 선택할지 결정

- 테스트하기 쉬운 항목부터 시작한다
  - 팀이 단위 테스트에 익숙하지 않은 경우
- 테스트하기 어려운 항목부터 시작한다
  - 팀이 단위 테스트에 익숙한 않은 경우에 추천
  - 다른 컴포넌트의 테스트 관련 문제도 해결할 수가 있음.

### 리팩토링 전에 통합 테스트 작성

코드를 리팩터링해서 단위 테스트를 작성한다면 리팩토링을 하더라도 기존 기능이 제대로 동작하도록, 운영 시스템에 대한 **통합 테스트를 선제적으로 작성**하는 것이 좋다.

1. 원래 시스템이 정상 작동하는지 확인하기 위해 통합 테스트(목이나 스텁 없이)를 추가한다.
2. 시스템에 추가하려는 기능에 대해 실패하는 테스트를 작성하거나 리팩토링 진행
3. 시스템을 작은 단위로 리팩토링하고 통합 테스트를 자주 실행하여 잘못된 부분이 없는지 체크

통합 테스트는 코드의 내부 구조나 의존성 주입을 고민하지 않아도 되어 단위 테스트에 비해 작성하기 쉬워보일 수 있지만, 로컬 환경에서 통합 테스트를 실핸하여려면 **시스템에 필요한 요소를 모두 준비해야하기 때문에 과정이 번거롭다**.

**핵심은 수정하거나 기능을 추가해야할 부분에만 집중하는 것이다.** 필요한 부분만 적절히 확장시키며 나중에 해결해야 할 문제들은 추후에 다룬다.

테스트를 추가하면서 리팩토링을 진행하고 단위 테스트를 작성하다 보면, 자연스럽게 시스템이 유지보수에 용이하고 테스트가 쉬운 구조로 바뀐다.

> 추천하는 레퍼런스 목록
>
> - <단위 테스트> -블라디미르 코리코프-
> - <레거시 코드 활용 전략> -마이클 페더스-
> - **CodeScene**을 활용한 프로덕션 코드 분석

## Advantages

<!-- (선택) 발표 주제를 적용했을 때 얻을 수 있는 이점이나 해결할 수 있는 문제 상황들에 대해 설명합니다. -->

## Disadvantages

<!-- (선택) 발표 주제를 적용했을 때 발생할 수 있는 side effect나 trade-off에 대해 설명합니다. -->

## Example Case

<!-- 발표 주제가 적용되어 있는 라이브러리, 실제 업무에 적용되어 있는 코드, 직접 만든 예시 코드, 자신의 느낀점 등을 첨부하여 이해를 돕습니다. -->

## Wrap-up

<!-- 발표를 마무리하며 발표 주제를 다시 요약하고 정리합니다. -->

- 레거시 코드에 대한 테스트를 작성할 때에는, 먼저 항목에 따라 우선순위를 정하는 것이 중요하다.
- 팀적으로 단위 테스트 경험이 부족하다면, 테스트가 쉬운 항목부터 우선적으로 추가하면서 자신감을 키워나가자.
- 대규모 리팩토링을 시작하기 전에는, 리팩토링을 하더라도 기존 기능이 제대로 동작하도록 **통합 테스트를 선제적으로 작성**하는 것이 좋다.
- 리팩토링이 끝난 이후에는 해당 통합 테스트를 더 작고 관리하기 쉬운 단위 테스트로 교체한다.
