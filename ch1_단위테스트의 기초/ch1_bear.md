# Chapter1 단위 테스트의 기초

## 1.2 단위테스트의 정의

### 테스트를 작성할 대상

- 주체(subject)
- 시스템(system)
- 테스트 다상(Suite Under Test, SUT)

```text
📚 TIP
SUT는 테스트 중인 주제, 시스템, 테스트의 모음(Suite)을 의미한다. 일부 사람들은 컴포넌트 클래스 코드를 의미하는 CUT(Component, class, code Under Test)라는 용어를 쓰기도 한다. 테스트하고자 하는 주요 대상을 SUT라고 한다.
```

### 작업 단위

- `진입점` -> `종료점`까지, 눈에 띄는 결과가 나타날 때까지 발생하는 모든 작업을 의미한다.
- 함수의 `body` -> 작업 단위 전체나 일부를 의미
- 함수의 `선언과 서명`은 body로의 진입점
- 함수의 `출력이나 실행결과`는 함수의 종료점

## 1.3 진입점과 종료점

- 작업 단위는 진입점과 종료점으로 구성되어있다.
- 작업 단위는 `의미 있는 작업`을 한다.
  - `의미 있는 작업`이란 간단히 값을 반환한느 것부터 상태를 변경하거나 서드 파티 코드를 호출하는 등 뭔가 눈에 띄는 동작을 의미한다.
- 이러한 동작을 `종료점`이라고 한다.

```text
🐻 생각
저희 server의 테스트 코드를 생각해보면 describe가 작업단위이고 test각 각 종료점이 아닐까 싶네용
```

```text
📚 TIP
코드를 작성할 때에는 query와 command가 있다. query는 상태를 변경하지 않고 값만을 변경한다. command는 상태를 변강하지만 값을 반환하지는 않는다. 보통은 둘을 결합해서 사용하지만 두 액션을 분리해서 설계하는 것이 더 나을 때가 많다.

query는 util 함수 같고... command는 흠.. 평소에 잘쓰지 않는 것 같네요. 분리를 해야한다면 모든 함수들을 좀 세분화 하라는 이야기 같아요
```

### 예제 코드

```javascript
let total = 0;

const totalSoFar = () => {
    return total;
}

const logger = makeLogger();

const sum = (numbers) => {
    const [a,b] = numbers.split(',');

    logger.info('this is a very important log output', {
        firstNumWas: a,
        secondNumWas: b
    })

    const result = Number.parseInt(a, 10) + Number.parseInt(b, 10);
    total += result;
    return result;
}
```

위 코드에서는 3가지 종료점이 있다.

1. result를 반환
2. total의 갑 변화
3. logger라는 서드파티 함수 호출

## 1.4 종료점의 유형

위 종료점의 각 유형은

1. undefined가 아닌 값을 반환한다. `(반환 값을 확인)`
2. 호출 전과 후의 상태값이 달라져 **내부 상태를 직접 보지 않고도 확인 가능하다.** `(달라진 상태 값 확인)`
3. 코드 실행 주도권이 없는 서드 파티 함수를 호출한다. `(호출 했는지 확인)`
   - 실행 주도권이 없다는 것은 Logger의 코드를 우리가 작성하지 않은 경우이다.

단위 테스트는 작업 단위를 호출하고 특정 종료점을 테스트 검증을 목표로 사용한다.
최종결과가 테스트가 검증하고자 하는 바와 다르면 단위 테스트는 실패한다.

## 1.5 다른 종료점, 다른 기법

종료점 마다 테스트를 만들어 분리하는 것이 코드 관리 측면에서 유리하고 종료점 종류에 따라 테스트 방법이 다소 다르다.

- **반환값이 있는 종료점**: 작업 단위를 실행하여 진입점을 호출하고 실행 결과 값을 확인
- **상태값을 변경하는 종료점**: 어떤 것을 호출 후 다른 것을 호출하여 확인 혹은 이전에 호출한 것을 다시 호출하여 모든것이 의도대로 흘러갔는지 확인
- **서드파티를 호출하는 종료점**: 모의 객체를 만들어 테스트 결과를 임의로 조작하는 방법

이중 서드파티를 호출하는(모의 객체로 테스트) 종료점이 제일 까다롭다고 한다.

## 1.6 처음부터 테스트코드 작성

```javascript
const sum = (numbers) => {
    const [a,b] = numbers.split(',');
    const result =  parseInt(a) + parseInt(b);

    return result;
}
```

위 코드를 직접 테스트 코드를 작성해보면 프레이워크 없이!

```javascript
const parseInt = () => {
    try{
        const result = sum('1,2');
        if ( result === 3) {
            console.log('parserTest example 1 PASSED');
        } else {
            throw new Error (`arserTest: expected 3 but was ${result}`);
        }
    } catch (e) {
        console.error(e);
    }
}
```

아래는 좀 더 범용적인 check 함수를 만들어서 테스트하기

```javascript
const assertEquals = (expected, actual) => {
    if (actual !== expected) {
        throw new Error(`Expeccted ${expected} but was ${actual}`);
    }
};

const check = (name, implementation) => {
    try {
        implementation();
        console.log(`${name} passed`)
    } catch (e) {
        console.error(`${name} FAILLED`, e.stack);
    }
};

check('sum with 2 numbers should sum them up', () => {
    const result = sum('1,2');
    assertEquals(3, result);
})

check('sum with mutiple digit numbers should sum them up', () => {
    const result = sum('10,20');
    assertEquals(30, result);
})

```

몇 가지 헬퍼 함수로 가독성과 생산성에 영향을 줬다는 것을 확인하자!

## 1.7 좋은 단위 테스트의 특징

- 좋은 테스트가 만족해야하는 항목
  - 테스트 작성자 의도를 이해하기 쉬워야한다.
  - 읽고 쓰기가 쉬워야한다.
  - 테스트를 자동화 할 수 있어야한다.
  - 같은 조건에서 실행 결과는 동일해야 한다.
  - 의미 있는 테스트여야 하고, 구체적인 결과를 제공하여 문제를 쉽게 파악하고 해결 할 수 있어야한다.
  - 누구나 쉽게 실행할 수 있어야한다.
  - 실패할 경우 무엇이 잘못 되었는지 쉽게 알 수 있어야한다.
- 그중에도 좋은 단뒤 테스트는
  - 빠르게 실행되어야 한다.
  - 테스트 환경을 일관되게 유지하고, 테스트 결과가 항상 예측이 가능해야한다.
  - 다른 테스트와 완전히 독립적으로 실행되어야 한다.
  - 시스템 파일, 네트워크, 데이터 베이스가 없어도 메모리 내에서 실행되어야 한다.
  - 가능한 한 동기적인 흐름으로 실행되어야 한다.

### 데이터 베이스나 다른 의존성을 스텁으로 대체하기

- 스텁을 사용 한다면 의존선ㅇ에 접근하지 않고도 테스트가 가능해 예측 가능한고 안정적으로 진행된다.
- 인메모리 데이터베이스는 실제 데이터베이스와 다르기 때문에 고려해야할 것들이 많다.
- 통합테스트에서는 실제 데이터베이스를 사용하는게 좋을 수도 있다.

### 비동기 처리를 동기 처리로 흉내내기

- await/async 나 Pormise를통해 동기적으로 처리해서 흉내를 낼 수 있다.

### 단위 테스트 체크리스트

- [ ] 2년 2개월 2년전에 만든 테스트가 잘 동작하는가?
- [ ] 2개월 전에 작성한 테스트를 팀 내 다른 동료가 실행했을 때 문제없이 결과를 받을 수 있는가?
- [ ] 내가 만든 모든 테스트가 수분 내로 실행된는가?
- [ ] 버튼 하나로 테스트를 실행 가능한가?
- [ ] 기본적인 테스트를 몇 분 내에 작성 가능한가?
- [ ] 다른 팀 코드에 버그가 있어도 내 테스트는 통과 하는가?
- [ ] 내 테스트는 다른 실행 환경에서도 동일한 결과를 보장하는가?
- [ ] 데이터베이스, 네트워크, 배포 없이도 동작하는가?
- [ ] 하나의 테스트를 삭제, 이동, 변경해도 다른 테스트는 영향을 받지 않고 잘 실행 되는가?

## 1.8 통합 테스트

- 통합테스트는 단위 테스트가 되지 못한 모든 테스트를 의미
- 통과를 하면 모두가 성공적이지만 실패를 하게 되면 모두가 실패한다는 점에서 원인을 파악하는데 힘들다.

`통합 테스트는 다른 팀이 만든 모듈, 외부 API나 서비스, 네트워크, 데이터베이스,스레드 등 실제 의존성을 완전히 제어할 수 없는 상태에서 작업 단위 테스트를 하는 것이다.`

통합은 실제 의존성을 사용하고 단위 테스트는 의존성을 격리해서 항상 일정한 결과를 받을 수 있도록 하는 것이다.

### 아래 체크리스트의 이유

- 2년 2개월 2년전에 만든 테스트가 잘 동작하는가?
  - 중간에 코드를 변경한 이후에도 잘 동작하는지 확인해야한다. 만약 동작하지 않는다면 회귀(이전에 동작하던 기능이 지금은 동작하지 않는 것)가 일어난 것이다.
- 2개월 전에 작성한 테스트를 팀 내 다른 동료가 실행했을 때 문제없이 결과를 받을 수 있는가?
  - 다른 사람의 코드를 변경할 떄 문제가 없길 바라기에 단위 테스트에서 신뢰를 쌓아 놓으면 안심하고 변경을 할 수 있다.
- 내가 만든 모든 테스트가 수분 내로 실행된는가?
  - 조금이라도 빨라야한다. 시간이 오래걸린다면 사람들은 자주 실행해보지 않게 된다.
- 버튼 하나로 테스트를 실행 가능한가?
  - 같은 이유로 자동화 되어있지 않다면 귀찮아 지기 때문이다.
- 기본적인 테스트를 몇 분 내에 작성 가능한가?
  - 테스트를 작성하는데 오래 걸린다면 겁을 먹거나 큰 문제만 신경 쓸 수 있기 때문이다.
- 다른 팀 코드에 버그가 있어도 내 테스트는 통과 하는가?,내 테스트는 다른 실행 환경에서도 동일한 결과를 보장하는가?,데이터베이스, 네트워크, 배포 없이도 동작하는가?
  - 의존성이 없는지 확인하는 질문
- 하나의 테스트를 삭제, 이동, 변경해도 다른 테스트는 영향을 받지 않고 잘 실행 되는가?
  - 통합 테스트에서는 외부의 영향을 받을 수 있기에 체크
  
즉 위 질문들은 통합테스트가 아닌지 확인하는 질문들 + 좋은 단위 테스트가 가져야하는 내용이다.

### 중요 포인트

- 가독성
- 유지 보수성
- 신뢰성

## 1.10 테스트 주도 개발 (TDD)

테스트를 먼저 작성하고 해당 테스트를 통과시키는 방향으로 개발을 하는 것을 말한다.
TDD는 코드를 작성하기 전에 테스트가 실패하는 것으을 확인하며 테스트가 의도대로 실패한다는 것을 확인하여 신뢰성을 확보할 수 있다는 것이다.

