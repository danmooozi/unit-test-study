<!-- 단순한 책 내용만 정리하는 스터디에서 벗어나 자신의 생각을 정리하고, 그걸 바탕으로 실무에 적용할 수 있는 내용을 찾는 스터디가 되었으면 좋겠습니다. -->
<!-- 참고한 글 - https://tech.kakaopay.com/post/frontend-study-journey/ -->

> [!Note]
> 정리한 챕터나 페이지 등을 자유롭게 기록

## Summary

<!-- 한 줄 요약을 통해 발표자는 본인이 주제를 정확하게 이해했는지 점검하고, 스터디원들은 한 눈에 주제를 파악할 수 있습니다. -->

실패한 테스트로 신뢰할 수 없는 테스트를 찾는 방법, 성공한 테스트로 신뢰할 수 없는 테스트를 찾는 방법에 대해서 알아보고
테스트 `신뢰도`를 높일 수 있는 방법을 소개한다.

## Concept

<!-- 책을 바탕으로 발표 주제의 이론적 개념 및 필요한 배경 지식을 설명합니다. -->

`좋은 테스트의 특징`

1. 신뢰성
2. 유지 보수성
3. 가독성

`테스트를 신뢰하는 경우와 아닌 경우`

- 신뢰하지 않는 경우
  - 테스트는 실패했지만 신경 쓰지 않는 경우 (거짓 양성)
  - 테스트가 가끔 통과하거나 테스트가 현재 작업과 관련 없다고 생각하거나 테스트에 버그가 있다고 느끼는 경우 (테스트에 버그가 있다고 생각하고 가볍게 무시)
  - 테스트가 통과했지만 의심스러운 경우 (거짓 음성)
  - "만약에 대비하여" 직접 디버깅하거나 프로그램을 테스트할 필요를 느끼는 경우
- 신뢰하는 경우
  - 테스트가 실패했을 때, 코드의 무언가가 잘못되었을까봐 걱정하는 경우
  - 테스트가 통과했을 때, 따로 디버깅이나 테스트할 필요가 없다고 느끼는 경우
  - 테스트가 통과한 경우

`실패한 테스트로 신뢰할 수 없는 테스트를 찾는 방법`

- 프로덕션 코드에서 실제 버그가 발견된 경우

  운이 종은 경우, 이 버그 때문에 테스트를 작성하는 것

- 테스트가 거짓 실패를 일으키는 경우

  종료점의 예상 결과를 잘못 설정했거나 테스트 대상 시스템을 잘못 사용한 것 이 원인일 수 있음.

  테스트에 버그가 있는지 찾는 방법

  - 잘못된 항목이나 잘못된 종료점을 검증하는 경우
  - 잘못된 값을 진입점에 전달하는 경우
  - 진입점을 절못 호출하는 경우

  테스트에 버그가 있다면 해야 할 일

  - 침착하게 버그 수정 후 다시 실행하여 통과하는지 확인
  - 테스트가 계속 실패한다면 프로덕션 코드에 문제가 있을 가능성이 큼

- 기능 변경으로 테스트가 최신 상태가 아닌 경우

  기능이 변경되면서 테스트가 현재 기능과 맞지 않아서 일 수 있음.

  해야 할 일

  - 테스트를 새로운 기능에 맞게 수정
  - 새로운 기능을 대상으로 새 테스트를 만들고 기존 테스는 삭제

- 테스트가 다른 테스트와 충돌하는 경우

  서로 다른 두 테스트가 실행할 때마다 하나는 실패하고 다른 하나는 성공하는 경우로 둘다 동시에 통과할 수 없음.

  해야 할 일

  - PO에게 물어보기

- 테스트가 불안정한 경우

  테스트가 불규칙하게 실패하는 상황으로 불안정한 테스트라고 하는데 이는 끝에서 설명예정

`테스트 신뢰도를 높일 수 있는 방법`

- 테스트에 로직을 적게 넣기
  - 불필요한 로직 제거
  - 여러 가지를 한꺼번에 검증하려는 경우 잘게 쪼개기
  - 헬퍼함수, 가짜 객체등은 이 로직을 검증하는 몇가지 테스트 추가하기

`성공한 테스트로 신뢰할 수 없는 테스트를 찾는 방법`

테스트가 통과하더라도 믿지 못하는 이유들

- 검증 부분이 없는 경우

테스트에 검증(assert) 부분이 없으면 함수 호출 내 검증 로직이 숨어있을 수 있음.

- 테스트를 이해할 수 없는 경우

  9장에서 더 자세히 다루기 때문에 어떤 문제들이 있는지만 확인

  - 이름이 적절하지 않은 테스트
  - 코드가 너무 길거나 복잡한 테스트
  - 변수 이름이 헷갈리게 되어 있는 테스트
  - 숨어 있는 로직이나 이해하기 어려운 가정을 포함한 테스트
  - 결과가 불분명한 테스트 (실패도 아니고 통과도 아닌 경우)
  - 충분한 정보를 제공하지 않는 테스트 메시지

- 단위 테스트가 불안정한 통합 테스트와 섞여 있는 경우

통합 테스트는 단위 테스트보다 의존성이 많아 불안정할 가능성이 더 높음.
이러한 테스트가 같은 폴더에 있거나 하나의 테스트 명령어로 함께 실행한다면 이 경우를 의심

- 테스트가 여러 가지를 한꺼번에 검증하는 경우

종료점 두개이상을 가진 상황

- 테스트가 자주 변경되는 경우

동적으로 만든 값을 테스트에 사용하는 상황

`불안정한 테스트 다루기`

불안정한 테스트는 코드의 변화가 없는데도 일관성 없는 결과를 반환하는 테스트

- 테스트 수준이 높을 수록 실제 의존성을 사용, 신뢰성은 높아지지만 동시에 불안정성 증가
- 테스트 수준이 낮을 수록 모든 의존성을 완전히 제어 가능, 예상과 다르다면 프로덕션 코드를 의심할 수 있음.

불안정한 테스트를 발견했을 때 할 수 있는 일

문제 정의

- 불안정함이 무엇을 의미하는지 명확히 정의

군집화

- 불안정하다고 판단되는 테스트는 별도의 카테고리나 폴더에 따로 모아 실행
  - 그 다음 수정, 리팩토링 또는 삭제 과정을 거침

상위 수준의 테스트에서 안정성을 유지하는 방법

- 테스트가 DB나 네트워크 서비스와 같은 외부 시스템을 변견했으면, 변경 내용 롤백
- 다른 테스트가 외부 시스템을 변경하지 않도록 방지
- 외부 시스템과 의존성을 제어할 수 있어야함

## Advantages

<!-- (선택) 발표 주제를 적용했을 때 얻을 수 있는 이점이나 해결할 수 있는 문제 상황들에 대해 설명합니다. -->

- 신뢰할 수 없는 테스트가 있는지 판단할 수 있는 기준이 생긴 것 같음.
- 신뢰성 있는 테스트를 위해 테스트 작성 시 고려해야할 것들에 대해서 알 수 있었음.

## Disadvantages

<!-- (선택) 발표 주제를 적용했을 때 발생할 수 있는 side effect나 trade-off에 대해 설명합니다. -->

## Example Case

<!-- 발표 주제가 적용되어 있는 라이브러리, 실제 업무에 적용되어 있는 코드, 직접 만든 예시 코드, 자신의 느낀점 등을 첨부하여 이해를 돕습니다. -->

컨테이너 이름 및 설명을 변경하는 함수를 테스트하는 코드로 그 과정에서 projects와 docker_infos 컬렉션을 업데이트하는 부분

여러 종료점을 동시에 테스트하는 코드인데 이런 코드도 분리하지 않고 작성했다면 신뢰할 수 없는 테스트 코드라고 해야할까?

[링크](https://github.com/goorm-dev/ide-site/pull/2813/commits/f8d51d48fafa2986de587130919ad64e6e75d435)

```javascript
beforeEach(() => {
  mockUpdateDocker
    .makeSpy({
      module: serDocker,
      funcName: "updateDocker",
    })
    .mockResolvedValue(true);

  mockUpdateProjectNameAndDescription
    .makeSpy({
      module: serProject,
      funcName: "updateProjectNameAndDescription",
    })
    .mockResolvedValue(true);
});

describe("updateContainerNameAndDescription DB 업데이트", () => {
  test("Docker와 Project 정보 업데이트 성공", async () => {
    await serContainer.updateContainerNameAndDescription({
      dockerId: mockDockerId,
      name: mockNewName,
      description: mockNewDescription,
    });

    expect(mockUpdateDocker.mock).toHaveBeenCalledWith({
      dockerId: mockDockerId,
      updateInfos: {
        name: mockNewName,
      },
    });

    expect(mockUpdateProjectNameAndDescription.mock).toHaveBeenCalledWith({
      dockerId: mockDockerId,
      name: mockNewName,
      description: mockNewDescription,
    });
  });
});
```

## Wrap-up

<!-- 발표를 마무리하며 발표 주제를 다시 요약하고 정리합니다. -->
